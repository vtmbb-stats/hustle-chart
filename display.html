<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VT Men's Basketball Hustle Display</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        
        .dark-mode {
            background-color: #111827 !important;
        }
        
        .light-mode {
            background-color: #f9fafb !important;
        }

        .table-header {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
    </style>
</head>
<body class="light-mode">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect, useRef } = React;

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDabJZx_x3SJEYk1dWwHJw0wUsp48yUWxc",
            authDomain: "vtmbb-hustle-chart.firebaseapp.com",
            projectId: "vtmbb-hustle-chart",
            storageBucket: "vtmbb-hustle-chart.firebasestorage.app",
            messagingSenderId: "210232739134",
            appId: "1:210232739134:web:78ed344affb9f8c0ba586f"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        const HustleDisplay = () => {
            const [darkMode, setDarkMode] = useState(false);
            const [recentPracticeData, setRecentPracticeData] = useState(null);
            const [seasonData, setSeasonData] = useState([]);
            const [sortColumn, setSortColumn] = useState('Total');
            const [seasonSortColumn, setSeasonSortColumn] = useState('Total');
            const [trendingData, setTrendingData] = useState({ up: [], down: [] });
            const [selectedPlayer, setSelectedPlayer] = useState('');
            const [selectedPeriod, setSelectedPeriod] = useState('season');
            const [recentPracticeView, setRecentPracticeView] = useState('most-recent');
            const [chartData, setChartData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [lastUpdated, setLastUpdated] = useState(null);
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            // All stats and their point values for Total calculation
            const statWeights = {
                // Positive stats
                'Offensive Rebound': 2,
                'Assist': 1,
                'Screen Assist': 1,
                'Gretzky': 1,
                'Steal': 1,
                'Deflection': 1,
                'Charge Drawn': 5,
                'Hustle Play': 1,
                'Positive Coach\'s Point': 1,
                // Negative stats
                'Turnover': -2,
                'Foul': -1,
                'No Crash-Get Back': -1,
                'Missed Close Out': -1,
                'Missed Box Out': -1,
                'Body Language': -1,
                'Negative Coach\'s Point': -1
            };

            const allStats = Object.keys(statWeights);

            // Player roster
            const players = [
                { number: 0, lastName: "Bedford", firstName: "Jailen" },
                { number: 1, lastName: "Lawal", firstName: "Tobi" },
                { number: 2, lastName: "Schutt", firstName: "Jaden" },
                { number: 3, lastName: "Hammond", firstName: "Ben" },
                { number: 4, lastName: "Pasha", firstName: "Izaiah" },
                { number: 5, lastName: "Jones", firstName: "Sin'Cere" },
                { number: 7, lastName: "Freeman", firstName: "Brett" },
                { number: 10, lastName: "Johnson", firstName: "Tyler" },
                { number: 13, lastName: "Hansberry", firstName: "Amani" },
                { number: 15, lastName: "Peterkin", firstName: "Snook" },
                { number: 17, lastName: "Avdalas", firstName: "Neo" },
                { number: 22, lastName: "Davis", firstName: "Solomon" },
                { number: 32, lastName: "Gurdak", firstName: "Christian" },
                { number: 77, lastName: "Dorn", firstName: "Antonio" }
            ];

            // Update body class when dark mode changes
            useEffect(() => {
                document.body.className = darkMode ? 'dark-mode' : 'light-mode';
            }, [darkMode]);

            // Calculate total score for a player's stats
            const calculateTotal = (stats) => {
                return allStats.reduce((total, stat) => {
                    const value = stats[stat] || 0;
                    return total + (value * statWeights[stat]);
                }, 0);
            };

            // Process recent practice data based on view selection
            const processRecentPracticeData = useCallback((practicesData, scrimmageData = {}) => {
                if (!practicesData || practicesData.length === 0) return null;

                let dataToProcess = {};
                let dateLabel = '';

                switch(recentPracticeView) {
                    case 'most-recent':
                        dataToProcess = practicesData[0].playerStats;
                        dateLabel = practicesData[0].date;
                        break;
                    case 'last-5':
                        const last5 = practicesData.slice(0, Math.min(5, practicesData.length));
                        dataToProcess = {};
                        last5.forEach(practice => {
                            Object.entries(practice.playerStats || {}).forEach(([playerKey, stats]) => {
                                if (!dataToProcess[playerKey]) {
                                    dataToProcess[playerKey] = {};
                                    allStats.forEach(stat => {
                                        dataToProcess[playerKey][stat] = 0;
                                    });
                                }
                                allStats.forEach(stat => {
                                    dataToProcess[playerKey][stat] = (dataToProcess[playerKey][stat] || 0) + (stats[stat] || 0);
                                });
                            });
                        });
                        dateLabel = `Last ${last5.length} Practices`;
                        break;
                    case 'last-10':
                        const last10 = practicesData.slice(0, Math.min(10, practicesData.length));
                        dataToProcess = {};
                        last10.forEach(practice => {
                            Object.entries(practice.playerStats || {}).forEach(([playerKey, stats]) => {
                                if (!dataToProcess[playerKey]) {
                                    dataToProcess[playerKey] = {};
                                    allStats.forEach(stat => {
                                        dataToProcess[playerKey][stat] = 0;
                                    });
                                }
                                allStats.forEach(stat => {
                                    dataToProcess[playerKey][stat] = (dataToProcess[playerKey][stat] || 0) + (stats[stat] || 0);
                                });
                            });
                        });
                        dateLabel = `Last ${last10.length} Practices`;
                        break;
                    case 'season':
                        dataToProcess = {};
                        practicesData.forEach(practice => {
                            Object.entries(practice.playerStats || {}).forEach(([playerKey, stats]) => {
                                if (!dataToProcess[playerKey]) {
                                    dataToProcess[playerKey] = {};
                                    allStats.forEach(stat => {
                                        dataToProcess[playerKey][stat] = 0;
                                    });
                                }
                                allStats.forEach(stat => {
                                    dataToProcess[playerKey][stat] = (dataToProcess[playerKey][stat] || 0) + (stats[stat] || 0);
                                });
                            });
                        });
                        dateLabel = 'Full Season';
                        break;
                    default:
                        dataToProcess = practicesData[0].playerStats;
                        dateLabel = practicesData[0].date;
                }

                return processPlayerData(dataToProcess, dateLabel, scrimmageData);
            }, [recentPracticeView]);

            // Load data from Firebase
            const loadData = useCallback(async () => {
                try {
                    setLoading(true);
                    
                    const practicesSnapshot = await db.collection('practiceSummaries')
                        .orderBy('practiceDate', 'desc')
                        .get();
                    
                    if (practicesSnapshot.empty) {
                        console.log('No practice data found');
                        setLoading(false);
                        return;
                    }

                    const practicesData = [];
                    practicesSnapshot.forEach(doc => {
                        const data = doc.data();
                        practicesData.push({
                            date: data.practiceDate,
                            playerStats: data.playerStats || {}
                        });
                    });

                    // Determine which practice dates to include based on current view
                    let includedPracticeDates = [];
                    switch(recentPracticeView) {
                        case 'most-recent':
                            includedPracticeDates = practicesData.length > 0 ? [practicesData[0].date] : [];
                            break;
                        case 'last-5':
                            includedPracticeDates = practicesData.slice(0, Math.min(5, practicesData.length)).map(p => p.date);
                            break;
                        case 'last-10':
                            includedPracticeDates = practicesData.slice(0, Math.min(10, practicesData.length)).map(p => p.date);
                            break;
                        case 'season':
                        default:
                            includedPracticeDates = practicesData.map(p => p.date);
                            break;
                    }

                    // Load scrimmage data for win/loss records, filtered by included dates
                    const scrimmageSnapshot = await db.collection('scrimmages').get();
                    const scrimmageData = {};
                    
                    scrimmageSnapshot.forEach(doc => {
                        const data = doc.data();
                        // Only include scrimmages from the practice dates we're viewing
                        if (data.practiceDate && includedPracticeDates.includes(data.practiceDate) && data.games && data.games.length > 0) {
                            data.games.forEach(game => {
                                // Only count games where teams are stored with the game
                                if (game.maroonTeam && game.grayTeam) {
                                    // Get all teams that had players in this game
                                    const teamsInGame = [
                                        { name: 'maroon', players: game.maroonTeam || [] },
                                        { name: 'gray', players: game.grayTeam || [] },
                                        { name: 'orange', players: game.orangeTeam || [] }
                                    ].filter(team => team.players.length > 0);
                                    
                                    // Find winning and losing teams
                                    const winningTeam = teamsInGame.find(team => team.name === game.winner);
                                    const losingTeams = teamsInGame.filter(team => team.name !== game.winner);
                                    
                                    // Add wins for winning team players (if team existed and had players)
                                    if (winningTeam) {
                                        winningTeam.players.forEach(player => {
                                            if (!scrimmageData[player.number]) {
                                                scrimmageData[player.number] = { wins: 0, losses: 0 };
                                            }
                                            scrimmageData[player.number].wins++;
                                        });
                                    }
                                    
                                    // Add losses for losing team players (only teams that had players)
                                    losingTeams.forEach(losingTeam => {
                                        losingTeam.players.forEach(player => {
                                            if (!scrimmageData[player.number]) {
                                                scrimmageData[player.number] = { wins: 0, losses: 0 };
                                            }
                                            scrimmageData[player.number].losses++;
                                        });
                                    });
                                }
                            });
                        }
                    });

                    const recentProcessed = processRecentPracticeData(practicesData, scrimmageData);
                    setRecentPracticeData(recentProcessed);

                    const seasonStats = {};
                    practicesData.forEach(practice => {
                        Object.entries(practice.playerStats || {}).forEach(([playerKey, stats]) => {
                            if (!seasonStats[playerKey]) {
                                seasonStats[playerKey] = {};
                                allStats.forEach(stat => {
                                    seasonStats[playerKey][stat] = 0;
                                });
                            }
                            
                            allStats.forEach(stat => {
                                seasonStats[playerKey][stat] = (seasonStats[playerKey][stat] || 0) + (stats[stat] || 0);
                            });
                        });
                    });

                    // For season data, always use full season scrimmage records
                    const fullSeasonScrimmageData = {};
                    scrimmageSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.games && data.games.length > 0) {
                            data.games.forEach(game => {
                                if (game.maroonTeam && game.grayTeam) {
                                    // Get all teams that had players in this game
                                    const teamsInGame = [
                                        { name: 'maroon', players: game.maroonTeam || [] },
                                        { name: 'gray', players: game.grayTeam || [] },
                                        { name: 'orange', players: game.orangeTeam || [] }
                                    ].filter(team => team.players.length > 0);
                                    
                                    // Find winning and losing teams
                                    const winningTeam = teamsInGame.find(team => team.name === game.winner);
                                    const losingTeams = teamsInGame.filter(team => team.name !== game.winner);
                                    
                                    // Add wins for winning team players (if team existed and had players)
                                    if (winningTeam) {
                                        winningTeam.players.forEach(player => {
                                            if (!fullSeasonScrimmageData[player.number]) {
                                                fullSeasonScrimmageData[player.number] = { wins: 0, losses: 0 };
                                            }
                                            fullSeasonScrimmageData[player.number].wins++;
                                        });
                                    }
                                    
                                    // Add losses for losing team players (only teams that had players)
                                    losingTeams.forEach(losingTeam => {
                                        losingTeam.players.forEach(player => {
                                            if (!fullSeasonScrimmageData[player.number]) {
                                                fullSeasonScrimmageData[player.number] = { wins: 0, losses: 0 };
                                            }
                                            fullSeasonScrimmageData[player.number].losses++;
                                        });
                                    });
                                }
                            });
                        }
                    });

                    const seasonProcessed = processPlayerData(seasonStats, 'Season Total', fullSeasonScrimmageData);
                    setSeasonData(seasonProcessed);

                    calculateTrending(practicesData);

                    setLastUpdated(new Date().toLocaleString());

                } catch (error) {
                    console.error('Error loading data:', error);
                } finally {
                    setLoading(false);
                }
            }, [processRecentPracticeData, recentPracticeView]);

            // Process player data into display format
            const processPlayerData = (playerStats, dateLabel, scrimmageData = {}) => {
                const processed = players.map(player => {
                    const playerKey = `player_${player.number}`;
                    const stats = playerStats[playerKey] || {};
                    
                    const playerData = {
                        number: player.number,
                        name: `${player.firstName} ${player.lastName}`,
                        displayName: React.createElement('div', {}, [
                            React.createElement('div', { key: 'first' }, player.firstName),
                            React.createElement('div', { key: 'last' }, player.lastName)
                        ]),
                        lastName: player.lastName,
                        ...stats
                    };
                    
                    allStats.forEach(stat => {
                        if (!(stat in playerData)) {
                            playerData[stat] = 0;
                        }
                    });
                    
                    playerData.Total = calculateTotal(stats);
                    
                    // Add scrimmage record
                    const record = scrimmageData[player.number] || { wins: 0, losses: 0 };
                    playerData.Record = `${record.wins}-${record.losses}`;
                    playerData.WinPercentage = record.wins + record.losses > 0 ? record.wins / (record.wins + record.losses) : 0;
                    
                    return playerData;
                });

                return {
                    date: dateLabel,
                    players: processed.sort((a, b) => b.Total - a.Total)
                };
            };

            // Calculate trending players (net change over last 5 practices)
            const calculateTrending = (practicesData) => {
                if (practicesData.length < 5) {
                    setTrendingData({ up: [], down: [] });
                    return;
                }

                const last5Practices = practicesData.slice(0, 5);
                const playerTrends = {};

                players.forEach(player => {
                    const playerKey = `player_${player.number}`;
                    const practiceScores = [];
                    
                    last5Practices.forEach(practice => {
                        const stats = practice.playerStats[playerKey] || {};
                        const total = calculateTotal(stats);
                        practiceScores.push(total);
                    });
                    
                    if (practiceScores.length === 5) {
                        const netChange = practiceScores[0] - practiceScores[4];
                        
                        playerTrends[player.number] = {
                            name: `${player.firstName} ${player.lastName}`,
                            netChange,
                            recentScore: practiceScores[0],
                            oldScore: practiceScores[4],
                            practices: practiceScores
                        };
                    }
                });

                const sorted = Object.values(playerTrends).sort((a, b) => b.netChange - a.netChange);
                
                setTrendingData({
                    up: sorted.slice(0, 3).filter(p => p.netChange > 0),
                    down: sorted.slice(-3).reverse().filter(p => p.netChange < 0)
                });
            };

            // Sort function for tables
            const sortPlayers = (players, column) => {
                return [...players].sort((a, b) => {
                    if (column === 'name') {
                        return a.lastName.localeCompare(b.lastName);
                    }
                    if (column === 'Record') {
                        return b.WinPercentage - a.WinPercentage;
                    }
                    return b[column] - a[column];
                });
            };

            // Load chart data for selected player
            const loadPlayerChart = useCallback(async () => {
                if (!selectedPlayer) {
                    setChartData(null);
                    return;
                }

                try {
                    const practicesSnapshot = await db.collection('practiceSummaries')
                        .orderBy('practiceDate', 'asc')
                        .get();
                    
                    const allChartPoints = [];
                    practicesSnapshot.forEach(doc => {
                        const data = doc.data();
                        const playerKey = `player_${selectedPlayer}`;
                        const stats = data.playerStats?.[playerKey] || {};
                        const total = calculateTotal(stats);
                        
                        allChartPoints.push({
                            date: data.practiceDate,
                            total: total
                        });
                    });

                    // Filter by period
                    let filteredPoints = allChartPoints;
                    if (selectedPeriod === 'last-5') {
                        filteredPoints = allChartPoints.slice(-5);
                    } else if (selectedPeriod === 'last-10') {
                        filteredPoints = allChartPoints.slice(-10);
                    }
                    // season shows all points (no filtering needed)

                    setChartData(filteredPoints);
                } catch (error) {
                    console.error('Error loading chart data:', error);
                }
            }, [selectedPlayer, selectedPeriod]);

            useEffect(() => {
                loadPlayerChart();
            }, [loadPlayerChart]);

            // Create/update chart
            useEffect(() => {
                if (!chartData || !chartRef.current) return;

                const ctx = chartRef.current.getContext('2d');
                
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                chartInstance.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartData.map(point => point.date),
                        datasets: [{
                            label: 'Hustle Score',
                            data: chartData.map(point => point.total),
                            borderColor: '#3B82F6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: darkMode ? '#fff' : '#374151'
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    color: darkMode ? '#9CA3AF' : '#6B7280'
                                },
                                grid: {
                                    color: darkMode ? '#374151' : '#E5E7EB'
                                }
                            },
                            y: {
                                ticks: {
                                    color: darkMode ? '#9CA3AF' : '#6B7280'
                                },
                                grid: {
                                    color: darkMode ? '#374151' : '#E5E7EB'
                                }
                            }
                        }
                    }
                });
            }, [chartData, darkMode]);

            useEffect(() => {
                loadData();
            }, [loadData, recentPracticeView]);

            const TableComponent = ({ data, sortCol, setSortCol, title, showDropdown = false }) => {
                if (!data) return React.createElement('div', { className: 'animate-pulse h-64' });

                const sortedPlayers = sortPlayers(data.players, sortCol);

                return React.createElement('div', { className: `rounded-lg shadow-lg ${darkMode ? 'bg-gray-800' : 'bg-white'} mb-6` }, [
                    React.createElement('div', { className: 'p-4 border-b', key: 'header' }, [
                        React.createElement('div', { className: 'flex justify-between items-center' }, [
                            React.createElement('h2', { className: `text-xl font-bold ${darkMode ? 'text-white' : 'text-gray-800'}` }, title),
                            showDropdown && React.createElement('select', {
                                value: recentPracticeView,
                                onChange: (e) => setRecentPracticeView(e.target.value),
                                className: `px-3 py-2 border rounded-md ${darkMode ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'}`
                            }, [
                                React.createElement('option', { value: 'most-recent' }, 'Most Recent Practice'),
                                React.createElement('option', { value: 'last-5' }, 'Last 5 Practices'),
                                React.createElement('option', { value: 'last-10' }, 'Last 10 Practices'),
                                React.createElement('option', { value: 'season' }, 'Full Season')
                            ])
                        ]),
                        React.createElement('p', { className: `text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}` }, data.date)
                    ]),
                    React.createElement('div', { className: 'overflow-x-auto', key: 'table' }, [
                        React.createElement('table', { className: 'w-full text-sm border-collapse' }, [
                            React.createElement('thead', { className: `table-header ${darkMode ? 'bg-gray-700' : 'bg-gray-50'}`, key: 'thead' }, [
                                React.createElement('tr', {}, [
                                    React.createElement('th', { className: `px-2 py-1 text-left cursor-pointer hover:bg-gray-600 border ${darkMode ? 'border-gray-600 text-gray-200' : 'border-gray-300 text-gray-700'} w-20`, onClick: () => setSortCol('name') }, 'Player'),
                                    ...allStats.map(stat => 
                                        React.createElement('th', { 
                                            key: stat, 
                                            className: `px-1 py-1 text-center cursor-pointer hover:bg-gray-600 min-w-8 border ${darkMode ? 'border-gray-600 text-gray-200' : 'border-gray-300 text-gray-700'}`,
                                            onClick: () => setSortCol(stat)
                                        }, stat)
                                    ),
                                    React.createElement('th', { 
                                        className: `px-1 py-1 text-center cursor-pointer hover:bg-gray-600 border ${darkMode ? 'border-gray-600 text-gray-200' : 'border-gray-300 text-gray-700'} w-12`,
                                        onClick: () => setSortCol('Record'),
                                        title: 'Scrimmage Record (W-L)'
                                    }, 'Record'),
                                    React.createElement('th', { 
                                        className: `px-2 py-1 text-center cursor-pointer font-bold border ${darkMode ? 'border-gray-600 text-gray-200' : 'border-gray-300 text-gray-700'} w-16 ${sortCol === 'Total' ? 'bg-blue-600 text-white' : 'hover:bg-gray-600'}`,
                                        onClick: () => setSortCol('Total')
                                    }, 'Total')
                                ])
                            ]),
                            React.createElement('tbody', { key: 'tbody' },
                                sortedPlayers.map((player, index) =>
                                    React.createElement('tr', {
                                        key: player.number,
                                        className: `border-b ${darkMode ? 'border-gray-700 hover:bg-gray-700' : 'border-gray-200 hover:bg-gray-50'}`
                                    }, [
                                        React.createElement('td', { className: `px-2 py-1 font-medium border ${darkMode ? 'border-gray-600 text-gray-200' : 'border-gray-300 text-gray-700'} w-20` }, player.displayName),
                                        ...allStats.map(stat => {
                                            const value = player[stat] || 0;
                                            const isNegative = statWeights[stat] < 0;
                                            return React.createElement('td', { 
                                                key: stat, 
                                                className: `px-1 py-1 text-center border ${darkMode ? 'border-gray-600' : 'border-gray-300'} ${value > 0 ? (isNegative ? 'text-red-500 font-semibold' : 'text-green-500 font-semibold') : darkMode ? 'text-gray-400' : 'text-gray-600'}`
                                            }, value > 0 ? value : '');
                                        }),
                                        React.createElement('td', { 
                                            className: `px-1 py-1 text-center border ${darkMode ? 'border-gray-600' : 'border-gray-300'} ${player.Record === '0-0' ? (darkMode ? 'text-gray-400' : 'text-gray-600') : 'text-blue-500 font-medium'}`,
                                            title: `Winning Percentage: ${(player.WinPercentage * 100).toFixed(1)}%`
                                        }, player.Record),
                                        React.createElement('td', { className: `px-2 py-1 text-center font-bold border ${darkMode ? 'border-gray-600' : 'border-gray-300'} ${player.Total > 0 ? 'text-green-500' : player.Total < 0 ? 'text-red-500' : darkMode ? 'text-gray-200' : 'text-gray-700'}` }, player.Total)
                                    ])
                                )
                            )
                        ])
                    ])
                ]);
            };

            if (loading) {
                return React.createElement('div', { className: 'max-w-7xl mx-auto p-4' }, [
                    React.createElement('div', { className: 'animate-pulse space-y-4' }, [
                        React.createElement('div', { className: 'h-8 bg-gray-300 rounded w-1/3' }),
                        React.createElement('div', { className: 'h-64 bg-gray-300 rounded' }),
                        React.createElement('div', { className: 'h-64 bg-gray-300 rounded' })
                    ])
                ]);
            }

            return React.createElement('div', { className: 'max-w-7xl mx-auto p-4' }, [
                // Header
                React.createElement('div', { className: `rounded-lg shadow-md p-4 mb-6 ${darkMode ? 'bg-gray-800' : 'bg-white'}`, key: "header" }, [
                    React.createElement('div', { className: "flex justify-between items-center" }, [
                        React.createElement('h1', { className: `text-2xl font-bold ${darkMode ? 'text-white' : 'text-gray-800'}` }, "Virginia Tech Men's Basketball - Hustle Display"),
                        React.createElement('div', { className: "flex items-center gap-4" }, [
                            React.createElement('button', {
                                onClick: loadData,
                                className: `px-4 py-2 rounded-md transition-colors ${darkMode ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-blue-500 text-white hover:bg-blue-600'}`
                            }, 'Refresh'),
                            React.createElement('button', {
                                onClick: () => setDarkMode(prev => !prev),
                                className: `px-3 py-2 rounded-md transition-colors ${darkMode ? 'bg-gray-700 text-white hover:bg-gray-600' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`
                            }, darkMode ? 'Light' : 'Dark'),
                            lastUpdated && React.createElement('div', { className: `text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}` }, [
                                React.createElement('div', { key: 'label' }, 'Last updated:'),
                                React.createElement('div', { className: 'font-medium', key: 'time' }, lastUpdated)
                            ])
                        ])
                    ])
                ]),

                // Recent Practice Table with Dropdown
                React.createElement(TableComponent, {
                    key: 'recent',
                    data: recentPracticeData,
                    sortCol: sortColumn,
                    setSortCol: setSortColumn,
                    title: 'Most Recent Practice',
                    showDropdown: true
                }),

                // Trending Players
                React.createElement('div', { className: `rounded-lg shadow-lg ${darkMode ? 'bg-gray-800' : 'bg-white'} mb-6`, key: 'trending' }, [
                    React.createElement('div', { className: 'p-4 border-b' }, [
                        React.createElement('h2', { className: `text-xl font-bold ${darkMode ? 'text-white' : 'text-gray-800'}` }, 'Trending Players'),
                        React.createElement('p', { className: `text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}` }, 'Net change in hustle score over last 5 practices')
                    ]),
                    React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4 p-4' }, [
                        React.createElement('div', { key: 'trending-up' }, [
                            React.createElement('h3', { className: `text-lg font-semibold text-green-600 mb-2` }, 'Trending Up'),
                            React.createElement('div', { className: 'space-y-2' },
                                trendingData.up.map((player, index) =>
                                    React.createElement('div', {
                                        key: index,
                                        className: `p-2 rounded ${darkMode ? 'bg-green-900/20' : 'bg-green-50'} border-l-4 border-green-500`
                                    }, [
                                        React.createElement('div', { className: 'font-semibold' }, player.name),
                                        React.createElement('div', { className: 'text-sm text-green-600' }, `+${player.netChange} net improvement`)
                                    ])
                                )
                            )
                        ]),
                        React.createElement('div', { key: 'trending-down' }, [
                            React.createElement('h3', { className: `text-lg font-semibold text-red-600 mb-2` }, 'Trending Down'),
                            React.createElement('div', { className: 'space-y-2' },
                                trendingData.down.map((player, index) =>
                                    React.createElement('div', {
                                        key: index,
                                        className: `p-2 rounded ${darkMode ? 'bg-red-900/20' : 'bg-red-50'} border-l-4 border-red-500`
                                    }, [
                                        React.createElement('div', { className: 'font-semibold' }, player.name),
                                        React.createElement('div', { className: 'text-sm text-red-600' }, `${player.netChange} net change`)
                                    ])
                                )
                            )
                        ])
                    ])
                ]),

                // Custom Player Chart
                React.createElement('div', { className: `rounded-lg shadow-lg ${darkMode ? 'bg-gray-800' : 'bg-white'}`, key: 'chart' }, [
                    React.createElement('div', { className: 'p-4 border-b' }, [
                        React.createElement('h2', { className: `text-xl font-bold ${darkMode ? 'text-white' : 'text-gray-800'}` }, 'Player Trend Chart'),
                        React.createElement('div', { className: 'flex gap-4 mt-2' }, [
                            React.createElement('select', {
                                value: selectedPlayer,
                                onChange: (e) => setSelectedPlayer(e.target.value),
                                className: `px-3 py-2 border rounded-md ${darkMode ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'}`
                            }, [
                                React.createElement('option', { value: '' }, 'Select Player'),
                                ...players.map(player =>
                                    React.createElement('option', {
                                        key: player.number,
                                        value: player.number
                                    }, `${player.firstName} ${player.lastName}`)
                                )
                            ]),
                            React.createElement('select', {
                                value: selectedPeriod,
                                onChange: (e) => setSelectedPeriod(e.target.value),
                                className: `px-3 py-2 border rounded-md ${darkMode ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'}`
                            }, [
                                React.createElement('option', { value: 'season' }, 'Full Season'),
                                React.createElement('option', { value: 'last-5' }, 'Last 5 Practices'),
                                React.createElement('option', { value: 'last-10' }, 'Last 10 Practices')
                            ])
                        ])
                    ]),
                    React.createElement('div', { className: 'p-4' }, [
                        selectedPlayer ? 
                            React.createElement('div', { style: { height: '400px' } }, [
                                React.createElement('canvas', { ref: chartRef })
                            ]) :
                            React.createElement('div', { className: `text-center py-16 ${darkMode ? 'text-gray-400' : 'text-gray-500'}` }, 'Select a player to view their trend chart')
                    ])
                ])
            ]);
        };

        ReactDOM.render(React.createElement(HustleDisplay), document.getElementById('root'));
    </script>
</body>
</html>
